
import { Card, Suit, CardColor, CardRank, PatternDetail, ScoreResult, Player, KaiChongDetail, ViolationRecord, SupportedLanguage, SpecialCaptureFlags } from '../types';
import { ID_WAN_WAN, ID_QIAN_WAN, ID_BAI_WAN, ID_20_WAN, ID_1_GUAN, ID_1_SUO, ID_9_WEN } from '../constants';
import { TRANSLATIONS } from '../constants';
import { evaluateKaiChong } from './kaiChongRules'; 

// --- HELPERS ---
const isRed = (card: Card) => card.color === CardColor.RED;
const isGreen = (card: Card) => card.color === CardColor.GREEN;
const isJinZhang = (card: Card) => isRed(card) || isGreen(card);

// --- PATTERN IDENTIFICATION ---
const identifyPatterns = (cards: Card[]): { details: PatternDetail[], score: number } => {
    const details: PatternDetail[] = [];
    let score = 0;
    // Implementation placeholder for advanced patterns (can be expanded later)
    return { details, score };
};

export const identifyKaiChongSeYang = (uCards: Card[]): { details: PatternDetail[], score: number } => {
    const details: PatternDetail[] = [];
    let score = 0;
    const U = uCards;
    const redCards = U.filter(c => isRed(c));
    const redCount = redCards.length;
    if (redCount >= 10) {
        const pts = 20 + (redCount - 10) * 5;
        details.push({ name: `Ten Red Gathering (${redCount})`, score: pts, cards: redCards, category: 'KC_SE_YANG' });
        score += pts;
    }
    return { details, score };
};

// --- EXPORTED FUNCTIONS ---

export interface CalculateRoundScoresOptions {
    players: Player[];
    bankerId: number;
    lang: SupportedLanguage;
    kaiChongHistory: KaiChongDetail[];
    violationLog: ViolationRecord[];
}

export const calculateRoundScores = ({
    players,
    bankerId,
    lang,
    kaiChongHistory,
    violationLog
}: CalculateRoundScoresOptions): ScoreResult[] => {
    const results: ScoreResult[] = [];

    // 1. Calculate Raw Scores (Points Generated by each player)
    players.forEach(p => {
        const mainTricks = p.trickPile.filter(t => t.round <= 8 && !t.isKaiChong).length;
        
        let diaoRaw = 0;
        let diaoChange = 0;

        // Base Diao Logic (Banker vs Peasant)
        if (p.id !== bankerId) {
            if (mainTricks === 0) { diaoRaw = -1; diaoChange = -1; }
            else if (mainTricks < 2) { diaoRaw = -0.5; diaoChange = -1; }
            else if (mainTricks === 2) { diaoRaw = 0; diaoChange = 0; }
            else if (mainTricks === 3) { diaoRaw = 0.5; diaoChange = 1; }
            else { diaoRaw = 1; diaoChange = 1; }
        } else {
            // Banker's Diao is placeholder, will be balanced later
            diaoRaw = mainTricks >= 4 ? 1 : -1;
            diaoChange = 0; 
        }

        const myKcMatches = kaiChongHistory.filter(h => h.playerId === p.id);
        const potCardIds = new Set(myKcMatches.map(m => m.matchedCard.id));
        const mainCapturedCards = p.capturedCards.filter(c => !potCardIds.has(c.id));

        const { details: seYangDetails, score: seYangScore } = identifyPatterns(mainCapturedCards);
        const { details: kcSeYangDetails, score: kcScore } = identifyKaiChongSeYang(p.capturedCards);
        
        let kaiChongPoints = 0;
        myKcMatches.forEach(m => kaiChongPoints += m.score);

        const myViolations = violationLog.filter(v => v.playerId === p.id);
        const patternDetails = [...seYangDetails, ...kcSeYangDetails];
        
        results.push({
            playerId: p.id,
            trickCount: mainTricks,
            diaoRawValue: diaoRaw,
            diaoPointChange: diaoChange, // Preliminary
            kaiZhuPointChange: 0, 
            qiaoMenPointChange: 0, 
            seYangPointChange: seYangScore,
            kaiChongPointChange: kaiChongPoints + kcScore,
            totalRoundChange: 0, // Will be calculated in Phase 3
            patterns: patternDetails.map(d => d.name),
            patternDetails: patternDetails,
            kaiChongDetails: myKcMatches,
            cardsWonCount: mainCapturedCards.length,
            visibleTrickCards: p.trickPile.filter(t => t.isFaceUp).map(t => t.card),
            scoringCards: mainCapturedCards.filter(c => isRed(c) || isGreen(c)),
            allCapturedCards: mainCapturedCards,
            violations: myViolations
        });
    });

    // 2. Balance Diao (Zero Sum Step 1)
    const banker = results.find(r => r.playerId === bankerId);
    if (banker) {
        let bankerDiaoTotal = 0;
        results.forEach(r => {
            if (r.playerId !== bankerId) {
                bankerDiaoTotal -= r.diaoPointChange;
            }
        });
        banker.diaoPointChange = bankerDiaoTotal;
    }

    // Initialize Total with Balanced Diao
    results.forEach(r => {
        r.totalRoundChange = r.diaoPointChange;
    });

    // 3. Balance Bonuses (Zero Sum Step 2)
    // Rule: Banker pays for Peasant bonuses. Peasants split Banker bonuses.
    results.forEach(scorer => {
        // Calculate points generated by this player
        const generatedPoints = scorer.seYangPointChange + scorer.kaiChongPointChange + scorer.kaiZhuPointChange + scorer.qiaoMenPointChange;
        
        if (generatedPoints > 0) {
            // Scorer gets the positive points
            scorer.totalRoundChange += generatedPoints;

            if (scorer.playerId !== bankerId) {
                // Case A: Scorer is Peasant -> Banker Pays full amount
                if (banker) {
                    banker.totalRoundChange -= generatedPoints;
                }
            } else {
                // Case B: Scorer is Banker -> Peasants split the cost
                const peasants = results.filter(r => r.playerId !== bankerId);
                const count = peasants.length;
                if (count > 0) {
                    const splitCost = Math.floor(generatedPoints / count);
                    const remainder = generatedPoints % count;
                    
                    peasants.forEach((p, idx) => {
                        let deduction = splitCost;
                        if (idx < remainder) deduction += 1; // Distribute remainder to ensure exact sum
                        p.totalRoundChange -= deduction;
                    });
                }
            }
        }
    });

    // 4. Balance Penalties (Zero Sum Step 3)
    // Rule: Violator pays fixed amount (e.g., 60), distributed to others (20 each).
    results.forEach(violator => {
        if (violator.violations.some(v => v.riskLevel === 'PENALTY')) {
            const penaltyAmount = 60;
            violator.totalRoundChange -= penaltyAmount;
            violator.penaltyReason = "严重违例 (包赔)"; // Flag for UI

            const others = results.filter(r => r.playerId !== violator.playerId);
            const count = others.length;
            if (count > 0) {
                const compensation = penaltyAmount / count; // Should be 20 for 3 players
                others.forEach(o => o.totalRoundChange += compensation);
            }
        }
    });

    return results;
};

export interface FindKaiChongMatchOptions {
    players: Player[];
    potCard: Card;
    lang: SupportedLanguage;
    history: KaiChongDetail[];
    currentAttempterId: number;
    specialCaptures: SpecialCaptureFlags;
}

export const findBestKaiChongMatch = ({
    players,
    potCard,
    lang,
    history,
    currentAttempterId,
    specialCaptures
}: FindKaiChongMatchOptions): KaiChongDetail | null => {
    const player = players.find(p => p.id === currentAttempterId);
    if (!player) return null;

    const result = evaluateKaiChong(player, potCard, history, specialCaptures);

    if (result) {
        return {
            playerId: currentAttempterId,
            matchedCard: potCard,
            sourceCards: result.validCards,
            score: result.score,
            matchType: result.matchType as any,
            priorityScore: result.priority, // Distance-based Priority
            description: result.description
        };
    }

    return null;
};
